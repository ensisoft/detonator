// Copyright (C) 2020-2021 Sami Väisänen
// Copyright (C) 2020-2021 Ensisoft http://www.ensisoft.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#pragma once

#include "config.h"

#include "warnpush.h"
#  include <glm/glm.hpp>
#include "warnpop.h"

#include <memory>
#include <string>
#include <variant>
#include <vector>
#include <unordered_map>
#include <mutex>

#include "base/bitflag.h"
#include "graphics/fwd.h"
#include "graphics/drawable.h"
#include "graphics/tilebatch.h"
#include "graphics/color4f.h"
#include "graphics/types.h"
#include "game/enum.h"
#include "game/tilemap.h"
#include "game/entity.h"
#include "game/scene.h"
#include "game/tree.h"
#include "engine/camera.h"
#include "engine/graphics.h"
#include "engine/types.h"
#include "engine/enum.h"

namespace engine
{
    class ClassLibrary;

    template<typename Node>
    class EntityDrawHook
    {
    public:
        virtual ~EntityDrawHook() = default;
        // This is a hook function to inspect and  modify the draw packet produced by the
        // given animation node. The return value can be used to indicate filtering.
        // If the function returns false the packet is dropped. Otherwise, it's added to the
        // current draw list with any possible modifications.
        virtual bool InspectPacket(const Node* node, DrawPacket& packet) { return true; }
        // This is a hook function to append extra draw packets to the current draw list
        // based on the node. Model is the current model to world transformation for this node.
        virtual void AppendPackets(const Node* node, gfx::Transform& model, std::vector<DrawPacket>& packets) {}
    protected:
    };

    template<typename Entity>
    class SceneDrawHook
    {
    public:
        virtual ~SceneDrawHook() = default;
        // Inspect the entity for any selective criteria to determine whether
        // the entity should be drawn or not. If the function returns true the
        // entity will get drawn and BeginDrawEntity will be called followed by
        // entity packet generation +  InspectPacket for each packet generated
        // for the entity. Then AppendPackets and EndDrawEntity will be called.
        // If the function returns false the entity is skipped and no further
        // processing is done on the entity in order to draw it.
        virtual bool FilterEntity(const Entity& entity) { return true; }
        // Implement this in order to do something when an entity drawing begins.
        virtual void BeginDrawEntity(const Entity& entity) {}
        // Implement this in order to do something when an entity drawing ends.
        virtual void EndDrawEntity(const Entity& entity) {}
        // Inspect and optionally modify a draw packet generated by the entity drawing.
        // You can modify the contents of this packet and/or use the return value to
        // indicate whether the packet should be drawn or dropped. If the function returns
        // true the packet is added to the scene packets and will get drawn. If the
        // function returns false the packet is dropped.
        virtual bool InspectPacket(const Entity& entity, DrawPacket& packet) { return true; }
        // Implement this to append any entity specific draw packets to the generated
        // scene draw packets.
        virtual void AppendPackets(const Entity& entity, gfx::Transform& model, std::vector<DrawPacket>& packets) {}
    private:
    };

    class TileBatchDrawHook
    {
    public:
        virtual bool FilterBatch(const DrawPacket& batch) { return true; }
        virtual void BeginDrawBatch(const DrawPacket& batch, gfx::Painter& painter) {};
        virtual void EndDrawBatch(const DrawPacket& batch, gfx::Painter& painter) {}
    };

    using EntityClassDrawHook     = EntityDrawHook<game::EntityNodeClass>;
    using EntityInstanceDrawHook  = EntityDrawHook<game::EntityNode>;
    using SceneClassDrawHook      = SceneDrawHook<game::EntityPlacement>;
    using SceneInstanceDrawHook   = SceneDrawHook<game::Entity>;

    class Renderer
    {
    public:
        using RenderingStyle = engine::RenderingStyle;
        using SceneProjection = game::SceneProjection;

        enum class Effects {
            Bloom
        };

        using BasicFogParams   = LowLevelRenderer::BasicFogParams;
        using BloomParams = LowLevelRenderer::BloomParams;
        using Camera = LowLevelRenderer::Camera;
        using Surface = LowLevelRenderer::Surface;

        struct FrameSettings {
            base::bitflag<Effects> effects;
            BasicFogParams fog;
            BloomParams bloom;
            Camera camera;
            Surface surface;
            RenderingStyle style = RenderingStyle::FlatColor;
            bool enable_fog = false;
            // render units (= scene units?)
            // add a little fudge to the renderable tile size in order to try to
            // close any possible gap between the tiles. if the tiles are exactly
            // the size they're supposed to be it's possible that some gaps
            // appear between them.
            float tile_size_fudge = 0.5f;
        };

        explicit Renderer(const ClassLibrary* classlib = nullptr);

        void SetClassLibrary(const ClassLibrary* classlib) noexcept
        { mClassLib = classlib; }
        void SetEditingMode(bool on_off) noexcept
        { mEditingMode = on_off; }
        void SetName(std::string name) noexcept
        { mRendererName = std::move(name); }

#if !defined(DETONATOR_ENGINE_BUILD)
        // these are not thread safe and are only available in the
        // editor and tests. The engine uses threads so we cannot
        // use these directly.
        void SetProjection(SceneProjection projection) noexcept
        { mProjection = projection; }
        void SetBloom(const BloomParams& bloom) noexcept
        { mFrameSettings.bloom = bloom; }
        void SetFog(const BasicFogParams& fog) noexcept
        { mFrameSettings.fog = fog; }
        void EnableFog(bool on_off) noexcept
        { mFrameSettings.enable_fog = on_off; }
        void EnableEffect(Effects effect, bool enabled) noexcept
        { mFrameSettings.effects.set(effect, enabled); }
        bool IsEnabled(Effects effect) const noexcept
        { return mFrameSettings.effects.test(effect); }
        void SetCamera(const Camera& camera) noexcept
        { mFrameSettings.camera = camera; }
        void SetSurface(const Surface& surface) noexcept
        { mFrameSettings.surface = surface; }
        void SetStyle(RenderingStyle style) noexcept
        { mFrameSettings.style = style; }
        void SetTileSizeFudge(float fudge) noexcept
        { mFrameSettings.tile_size_fudge = fudge; }
        void SetPacketFilter(PacketFilter* filter) noexcept
        { mPacketFilter = filter; }
        void SetLowLevelRendererHook(LowLevelRendererHook* hook) noexcept
        { mLowLevelRendererHook = hook; }
        auto GetNumPaintNodes() const noexcept
        { return mPaintNodes.size(); }
#endif
        // This the current *real* rendering API used by the engine.

        // Create the internal renderer data structures for visually representing
        // the contents of the given scene.
        void CreateRendererState(const game::Scene& scene, const game::Tilemap* map);

        // Update the internal renderer data structures by applying changes to the
        // scene in the renderers data structures.
        void UpdateRendererState(const game::Scene& scene, const game::Tilemap* map);

        // Update the current frame rendering state, animate materials etc.
        // note that when doing multi-threaded render/update this
        // method cannot run in parallel with DrawFrame.
        void Update(const game::Scene& scene, const game::Tilemap* map, double time, float dt);

        // Create the draw commands for the next frame that to be drawn
        // by the call to DrawFrame. This method cannot run in parallel
        // with with DrawFrame.
        void CreateFrame(const game::Scene& scene, const game::Tilemap* map, const FrameSettings& settings);

        // Draw the current frame rendering state, i.e. the currently
        // enqueued and created draw commands.
        void DrawFrame(gfx::Device& painter) const;

#if !defined(DETONATOR_ENGINE_BUILD)
        void UpdateRendererState(const game::SceneClass& scene, const game::Tilemap* map);
        void UpdateRendererState(const game::EntityClass& entity);
        void UpdateRendererState(const game::Entity& entity);
        void UpdateRendererState(const game::Tilemap& map);

        void Update(const game::EntityClass& entity, double time, float dt);
        void Update(const game::SceneClass& scene, const game::Tilemap* map, double time, float dt);
        void Update(const game::Tilemap& map, double time, float dt);
        void Update(const game::Entity& entity, double time, float dt);

        void Update(const game::Scene& scene, double time, float dt)
        {
            Update(scene, nullptr, time, dt);
        }
        void Update(const game::SceneClass& scene, double time, float dt)
        {
            Update(scene, nullptr, time, dt);
        }

        void CreateFrame(const game::SceneClass& scene, const game::Tilemap* map, SceneClassDrawHook* hook = nullptr);
        void CreateFrame(const game::EntityClass& entity, EntityClassDrawHook* hook = nullptr);
        void CreateFrame(const game::Entity& entity, EntityInstanceDrawHook* hook = nullptr);
        void CreateFrame(const game::Tilemap& map, bool draw_render_layer, bool draw_data_layer,
                         TileBatchDrawHook* hook = nullptr);

        void CreateFrame(const game::Scene& scene, const game::Tilemap* map)
        {
            CreateFrame(scene, map, mFrameSettings);
        }

        void BeginFrame();
        void EndFrame();
        void ClearPaintState();
#endif
    private:
        struct TileBatch {
            enum class Type {
                Render, Data
            };
            Type type = Type::Render;
            std::vector<gfx::TileBatch::Tile> tiles;
            std::shared_ptr<const gfx::Material> material;
            // the index of the layer in the map
            std::uint8_t padding_;
            std::uint8_t sort_key = 0;
            std::uint16_t layer_index = 0;
            std::int16_t render_layer = 0;
            std::int16_t depth  = 0;
            std::uint32_t row   = 0;
            std::uint32_t col   = 0;
            glm::vec3 tile_size = {0.0f, 0.0f, 0.0f};
            glm::vec2 render_size = {0.0f, 0.0f};
        };

        template<typename EntityType, typename NodeType>
        void CreatePaintNodes(const EntityType& entity, gfx::Transform& transform, std::string prefix = "");

        struct PaintNode;
        struct LightNode;

        template<typename EntityType, typename EntityNodeType>
        void UpdateDrawableResources(const EntityType& entity, const EntityNodeType& entity_node, PaintNode& paint_node,
                                     SceneProjection mode, double time, float dt) const;
        template<typename EntityType, typename EntityNodeType>
        void UpdateTextResources(const EntityType& entity, const EntityNodeType& entity_node, PaintNode& paint_node,
                                 SceneProjection mode, double time, float dt) const;
        template<typename EntityType, typename EntityNodeType>
        void UpdateLightResources(const EntityType& entity, const EntityNodeType& entity_node, LightNode& light_node,
                                  SceneProjection mode, double time, float dt) const;

        template<typename EntityType, typename EntityNodeType>
        void CreateDrawableResources(const EntityType& entity, const EntityNodeType& entity_node, PaintNode& paint_node) const;
        template<typename EntityType, typename EntityNodeType>
        void CreateTextResources(const EntityType& entity, const EntityNodeType& entity_node, PaintNode& paint_node) const;
        template<typename EntityType, typename EntityNodeType>
        void CreateLightResources(const EntityType& entity, const EntityNodeType& entity_node, LightNode& light_node) const;

        template<typename EntityType, typename EntityNodeType>
        void CreateDrawableDrawPackets(const EntityType& entity,
                                       const EntityNodeType& entity_node,
                                       const PaintNode& paint_node,
                                       const FrameSettings& settings,
                                       SceneProjection mode,
                                       std::vector<DrawPacket>& packets,
                                       EntityDrawHook<EntityNodeType>* hook) const;
        template<typename EntityType, typename EntityNodeType>
        void CreateTextDrawPackets(const EntityType& entity,
                                   const EntityNodeType& entity_node,
                                   const PaintNode& paint_node,
                                   const FrameSettings& settings,
                                   SceneProjection mode,
                                   std::vector<DrawPacket>& packets,
                                   EntityDrawHook<EntityNodeType>* hook) const;

        template<typename EntityType, typename EntityNodeType>
        void CreateLights(const EntityType& entity,
                          const EntityNodeType& entity_node,
                          const LightNode& light_node,
                          const FrameSettings& settings,
                          SceneProjection projection,
                          std::vector<Light>& lights) const;

        void OffsetPacketLayers(std::vector<DrawPacket>& packets, std::vector<Light>& lights) const;

        void GenerateMapDrawPackets(const game::Tilemap& map,
                                    const FrameSettings& settings,
                                    const std::vector<TileBatch>& batches,
                                    std::vector<DrawPacket>& packets) const;

        void PrepareMapTileBatches(const game::Tilemap& map,
                                   const FrameSettings& settings,
                                   std::vector<TileBatch>& batches,
                                   bool draw_render_layer,
                                   bool draw_data_layer,
                                   bool obey_klass_flags,
                                   bool use_batching);
        template<typename LayerType>
        void PrepareDataLayerTileBatches(const game::Tilemap& map,
                                         const game::TilemapLayer& layer,
                                         const game::URect& visible_region,
                                         std::vector<TileBatch>& batches,
                                         std::uint16_t layer_index,
                                         bool use_batching);
        template<typename LayerType>
        void PrepareRenderLayerTileBatches(const game::Tilemap& map,
                                           const game::TilemapLayer& layer,
                                           const game::URect& visible_region,
                                           std::vector<TileBatch>& batches,
                                           std::uint16_t layer_index,
                                           bool use_batching);

        void SortTilePackets(std::vector<DrawPacket>& packets) const;

        void ComputeTileCoordinates(const game::Tilemap& map,
                                    std::size_t packet_start_index,
                                    std::vector<DrawPacket>& packets) const;

        std::shared_ptr<const gfx::Material> GetTileMaterial(const game::Tilemap& map,
                                                             std::uint16_t layer_index,
                                                             std::uint16_t material_index);
    private:
        const ClassLibrary* mClassLib = nullptr;
        std::string mRendererName;
        bool mEditingMode = false;

        struct PaintNode {
            bool visited = false;
            std::string materialId;
            std::string drawableId;
            std::shared_ptr<gfx::Material> material;
            std::shared_ptr<gfx::Drawable> drawable;
            glm::vec2 world_scale;
            glm::vec2 world_pos;
            float world_rotation = 0.0f;
        };

        struct LightNode {
            bool visited = false;
            std::shared_ptr<gfx::BasicLight> light;
            glm::vec2 world_scale;
            glm::vec2 world_pos;
            float world_rotation = 0.0f;
        };

        struct TilemapLayerPaletteEntry {
            std::string material_id;
            std::shared_ptr<gfx::Material> material;
        };
        using TilemapLayerPalette = std::vector<TilemapLayerPaletteEntry>;

        std::mutex mRendererLock;
        std::unordered_map<std::string, PaintNode> mPaintNodes;
        std::unordered_map<std::string, LightNode> mLightNodes;
        std::vector<TilemapLayerPalette> mTilemapPalette;

#if !defined(DETONATOR_ENGINE_BUILD)
        SceneProjection mProjection = SceneProjection::AxisAlignedOrthographic;
        PacketFilter* mPacketFilter = nullptr;
        LowLevelRendererHook* mLowLevelRendererHook = nullptr;
#endif
        mutable std::mutex mFrameLock;
        mutable std::vector<DrawPacket> mRenderBuffer;
        mutable std::vector<Light> mLightBuffer;
        mutable FrameSettings mFrameSettings;
    };

} // namespace
