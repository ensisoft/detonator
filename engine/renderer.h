// Copyright (C) 2020-2021 Sami Väisänen
// Copyright (C) 2020-2021 Ensisoft http://www.ensisoft.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#pragma once

#include "config.h"

#include "warnpush.h"
#  include <glm/glm.hpp>
#include "warnpop.h"

#include <memory>
#include <string>
#include <variant>
#include <vector>
#include <unordered_map>

#include "base/bitflag.h"
#include "graphics/fwd.h"
#include "graphics/drawable.h"
#include "game/enum.h"
#include "game/tilemap.h"
#include "game/entity.h"
#include "game/scene.h"
#include "game/tree.h"
#include "engine/graphics.h"
#include "engine/types.h"

namespace engine
{
    class ClassLibrary;

    template<typename Node>
    class EntityDrawHook
    {
    public:
        virtual ~EntityDrawHook() = default;
        // This is a hook function to inspect and  modify the draw packet produced by the
        // given animation node. The return value can be used to indicate filtering.
        // If the function returns false the packet is dropped. Otherwise, it's added to the
        // current draw list with any possible modifications.
        virtual bool InspectPacket(const Node* node, DrawPacket& packet) { return true; }
        // This is a hook function to append extra draw packets to the current draw list
        // based on the node. Model is the current model to world transformation for this node.
        virtual void AppendPackets(const Node* node, gfx::Transform& model, std::vector<DrawPacket>& packets) {}
    protected:
    };

    template<typename Entity>
    class SceneDrawHook
    {
    public:
        virtual ~SceneDrawHook() = default;
        // Inspect the entity for any selective criteria to determine whether
        // the entity should be drawn or not. If the function returns true the
        // entity will get drawn and BeginDrawEntity will be called followed by
        // entity packet generation +  InspectPacket for each packet generated
        // for the entity. Then AppendPackets and EndDrawEntity will be called.
        // If the function returns false the entity is skipped and no further
        // processing is done on the entity in order to draw it.
        virtual bool FilterEntity(const Entity& entity) { return true; }
        // Implement this in order to do something when an entity drawing begins.
        virtual void BeginDrawEntity(const Entity& entity) {}
        // Implement this in order to do something when an entity drawing ends.
        virtual void EndDrawEntity(const Entity& entity) {}
        // Inspect and optionally modify a draw packet generated by the entity drawing.
        // You can modify the contents of this packet and/or use the return value to
        // indicate whether the packet should be drawn or dropped. If the function returns
        // true the packet is added to the scene packets and will get drawn. If the
        // function returns false the packet is dropped.
        virtual bool InspectPacket(const Entity& entity, DrawPacket& packet) { return true; }
        // Implement this to append any entity specific draw packets to the generated
        // scene draw packets.
        virtual void AppendPackets(const Entity& entity, gfx::Transform& model, std::vector<DrawPacket>& packets) {}
    private:
    };

    class PacketFilter
    {
    public:
        virtual ~PacketFilter() = default;
        virtual bool InspectPacket(const DrawPacket& packet) { return true; }
    };

    class TileBatchDrawHook
    {
    public:
        virtual bool FilterBatch(const TileBatch& batch) { return true; }
        virtual void BeginDrawBatch(const TileBatch& batch, const glm::mat4& model, gfx::Painter& painter) {};
        virtual void EndDrawBatch(const TileBatch& batch, const glm::mat4& model, gfx::Painter& painter) {}
    };

    using EntityClassDrawHook     = EntityDrawHook<game::EntityNodeClass>;
    using EntityInstanceDrawHook  = EntityDrawHook<game::EntityNode>;
    using SceneClassDrawHook      = SceneDrawHook<game::EntityPlacement>;
    using SceneInstanceDrawHook   = SceneDrawHook<game::Entity>;

    class Renderer
    {
    public:
        enum class Effects {
            Bloom
        };

        struct BloomParams {
            float threshold = 0.0f;
            float red   = 0.0f;
            float green = 0.0f;
            float blue  = 0.0f;
        };

        struct Camera {
            glm::vec2 position = {0.0f, 0.0f};
            glm::vec2 scale    = {1.0f, 1.0f};
            game::FRect viewport;
            float rotation = 0.0f;
        };

        // The rendering window/surface details.
        struct Surface {
            // Device viewport in which part of the surface to render.
            IRect viewport;
            // Rendering surface size in pixels.
            USize size;
        };

        Renderer(const ClassLibrary* classlib = nullptr);

        inline void SetBloom(const BloomParams& bloom) noexcept
        { mBloom = bloom; }
        inline void SetClassLibrary(const ClassLibrary* classlib) noexcept
        { mClassLib = classlib; }
        inline void SetEditingMode(bool on_off) noexcept
        { mEditingMode = on_off; }
        inline void SetName(std::string name) noexcept
        { mRendererName = std::move(name); }
        inline void EnableEffect(Effects effect, bool enabled) noexcept
        { mEffects.set(effect, enabled); }
        inline bool IsEnabled(Effects effect) const noexcept
        { return mEffects.test(effect); }
        inline void SetCamera(const Camera& camera) noexcept
        { mCamera = camera; }
        inline void SetSurface(const Surface& surface) noexcept
        { mSurface = surface; }
        inline void SetPacketFilter(PacketFilter* filter)
        { mPacketFilter = filter; }

        void BeginFrame();

        // This the current *real* rendering API used by the engine.

        // Create the internal renderer data structures for visually representing
        // the contents of the given scene.
        void CreateRenderStateFromScene(const game::Scene& scene);
        // Create and update the internal renderer data structures for visually
        // representing the contents of the given scene.
        void UpdateRenderStateFromScene(const game::Scene& scene);
        // Draw the current rendering state.
        void Draw(gfx::Device& painter, const game::Tilemap* map = nullptr);
        // Update the renderer state, i.e. update/animate materials etc.
        void Update(float time, float dt);

        // The following API methods used by the editor to draw some
        // edit time representations of things.

        void Draw(const game::Entity& entity,
                  gfx::Device& device,
                  EntityInstanceDrawHook* hook = nullptr)
        {
            gfx::Transform model;
            Draw(entity, device, model, hook);
        }
        void Draw(const game::EntityClass& entity,
                  gfx::Device& device,
                  EntityClassDrawHook* hook = nullptr)
        {
            gfx::Transform model;
            Draw(entity, device, model, hook);
        }

        void Draw(const game::Entity& entity,
                  gfx::Device& device, gfx::Transform& model,
                  EntityInstanceDrawHook* hook = nullptr);
        void Draw(const game::EntityClass& entity,
                  gfx::Device& device, gfx::Transform& model,
                  EntityClassDrawHook* hook = nullptr);

        void Draw(const game::Scene& scene,
                  gfx::Device& device,
                  SceneInstanceDrawHook* scene_hook = nullptr);
        void Draw(const game::SceneClass& scene, const game::Tilemap* map,
                  gfx::Device& device,
                  SceneClassDrawHook* scene_hook = nullptr,
                  bool draw_map_render_layers = true,
                  bool draw_map_data_layers = false);

        void Draw(const game::Tilemap& map,
                  gfx::Device& device,
                  TileBatchDrawHook* hook,
                  bool draw_render_layer,
                  bool draw_data_layer);

        // Update the visual representation of the renderer's paint node
        // based on the given animation node.
        void Update(const game::EntityNodeClass& node, float time, float dt);
        void Update(const game::EntityClass& entity, float time, float dt);
        void Update(const game::EntityNode& node, float time, float dt);
        void Update(const game::Entity& entity, float time, float dt);
        void Update(const game::SceneClass& scene, float time, float dt);
        void Update(const game::Scene& scene, float time, float dt);

        void EndFrame();

        void ClearPaintState();

        size_t GetNumPaintNodes() const
        { return mPaintNodes.size(); }
    private:
        template<typename SceneType, typename SceneNodeType,
                 typename EntityType, typename EntityNodeType>
        void DrawScene(const SceneType& scene, const game::Tilemap* map,
                       gfx::Device& device,
                       SceneDrawHook<SceneNodeType>* scene_hook,
                       bool draw_map_render_layers, bool draw_map_data_layers);

        template<typename EntityType, typename NodeType>
        void MapEntity(const EntityType& entity, gfx::Transform& transform);

        template<typename EntityType, typename NodeType>
        void DrawEntity(const EntityType& entity,
                        gfx::Device& device,
                        gfx::Transform& transform,
                        EntityDrawHook<NodeType>* hook);

        struct PaintNode;
        template<typename EntityNodeType>
        void UpdateNode(PaintNode& paint_node, float time, float dt);

        template<typename EntityType, typename EntityNodeType>
        void CreateDrawResources(PaintNode& paint_node);

        template<typename EntityType, typename EntityNodeType>
        void GenerateDrawPackets(PaintNode& paint_node,
                                 std::vector<DrawPacket>& packets,
                                 EntityDrawHook<EntityNodeType>* hook);

        void OffsetPacketLayers(std::vector<DrawPacket>& packets) const;
        void DrawScenePackets(gfx::Device& device, const std::vector<DrawPacket>& packets) const;
        void DrawEditorPackets(gfx::Device& device, const std::vector<DrawPacket>& packets) const;

        void PrepareMapTileBatches(const game::Tilemap& map,
                                   std::vector<TileBatch>& batches,
                                   bool draw_render_layer,
                                   bool draw_data_layer,
                                   bool obey_klass_flags);
        template<typename LayerType>
        void PrepareDataLayerTileBatches(const game::Tilemap& map,
                                         const game::TilemapLayer& layer,
                                         const game::URect& visible_region,
                                         std::vector<TileBatch>& batches,
                                         std::uint16_t layer_index);
        template<typename LayerType>
        void PrepareRenderLayerTileBatches(const game::Tilemap& map,
                                           const game::TilemapLayer& layer,
                                           const game::URect& visible_region,
                                           std::vector<TileBatch>& batches,
                                           std::uint16_t layer_index);

        void DrawTileBatches(const game::Tilemap& map,
                             TileBatchDrawHook* hook,
                             std::vector<TileBatch>& batches,
                             gfx::Device& device);
        void SortTileBatches(std::vector<TileBatch>& batches) const;

        void SortTilePackets(std::vector<DrawPacket>& packets) const;

        void ComputeTileCoordinates(const glm::mat4& scene_view_to_clip,
                                    const glm::mat4& scene_world_to_view,
                                    const glm::mat4& map_view_to_clip,
                                    const glm::mat4& map_world_to_view,
                                    const game::Tilemap& map,
                                    std::size_t packet_start_index,
                                    std::vector<DrawPacket>& packets) const;


        std::shared_ptr<const gfx::Material> GetTileMaterial(const game::Tilemap& map,
                                                             std::uint16_t layer_index,
                                                             std::uint16_t material_index);

    private:
        const ClassLibrary* mClassLib = nullptr;
        using EntityRef = std::variant<
                const game::Entity*,
                const game::EntityClass*>;
        using EntityNodeRef = std::variant<
                const game::EntityNode*,
                const game::EntityNodeClass*>;

        struct PaintNode {
            bool visited = false;
            std::string text_material_id;
            std::string item_material_id;
            std::string item_drawable_id;
            std::shared_ptr<gfx::Material> text_material;
            std::shared_ptr<gfx::Drawable> text_drawable;
            std::shared_ptr<gfx::Material> item_material;
            std::shared_ptr<gfx::Drawable> item_drawable;
            glm::vec2 world_scale;
            glm::vec2 world_pos;
            float world_rotation = 0.0f;
            EntityRef     entity;
            EntityNodeRef entity_node;
#if !defined(NDEBUG)
            std::string debug_name;
#endif
        };
        std::unordered_map<std::string, PaintNode> mPaintNodes;

        struct TilemapLayerPaletteEntry {
            std::string material_id;
            std::shared_ptr<gfx::Material> material;
        };

        using TilemapLayerPalette = std::vector<TilemapLayerPaletteEntry>;
        std::vector<TilemapLayerPalette> mTilemapPalette;

        std::string mRendererName;
        base::bitflag<Effects> mEffects;
        bool mEditingMode = false;
        BloomParams mBloom;
        Camera mCamera;
        Surface mSurface;

        PacketFilter* mPacketFilter = nullptr;
    };

} // namespace
