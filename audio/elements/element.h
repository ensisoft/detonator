// Copyright (C) 2020-2025 Sami Väisänen
// Copyright (C) 2020-2025 Ensisoft http://www.ensisoft.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#pragma once

#include "config.h"

#include <memory>
#include <string>
#include <queue>


#include "audio/buffer.h"
#include "audio/format.h"
#include "audio/command.h"
#include "audio/loader.h"
#include "audio/port.h"

namespace audio
{
    // Audio processing element. Each element can have multiple input
    // and output ports with various port format settings. During
    // audio processing the element will normally read a buffer of PCM
    // data from its input ports, perform processing on the data and
    // then push the results out into its output ports.
    class Element
    {
    public:
        using Allocator  = audio::BufferAllocator;
        using Command    = audio::Command;
        using Event      = audio::Event;
        using Loader     = audio::Loader;
        using EventQueue = std::queue<std::unique_ptr<Event>>;

        struct PrepareParams {
            bool enable_pcm_caching = false;
        };

        virtual ~Element() = default;
        // Get the machine generated immutable ID of the element.
        virtual std::string GetId() const = 0;
        // Get the human-readable name of the element.
        virtual std::string GetName() const = 0;
        // Get the dynamic type name of the element.
        virtual std::string GetType() const = 0;
        // Returns whether the element is done producing audio buffers.
        virtual bool IsSourceDone() const { return false; }
        // Return whether the element is a source element, i.e. producer of
        // audio buffers.
        virtual bool IsSource() const { return false; }
        // Prepare the element for processing. Returns true if
        // successful or false on error and error details are logged.
        virtual bool Prepare(const Loader& loader, const PrepareParams& params)
        { return true; }
        // Run the element in order to process 'milliseconds' worth of
        // audio data. The number of milliseconds is not a request but
        // an exact measure of PMC data that must be produced. The only
        // exception is when an element is winding down and is producing
        // its last audio data in which case the output buffer may contain
        // less than 'milliseconds' worth of data.
        // Any non-source input will likely ignore the milliseconds parameter
        // and process data in whole buffers instead.
        // EventQueue is the queue of outgoing events generated by the element
        // (and its descendants).
        virtual void Process(Allocator& allocator, EventQueue& events, unsigned milliseconds) {}
        // Advance the element time in milliseconds based on the latest
        // duration of the latest audio buffer sent to the audio device.
        virtual void Advance(unsigned int ms) {}
        // Perform element shutdown/cleanup.
        virtual void Shutdown() {}
        // Get the number of input ports this element has.
        virtual unsigned GetNumInputPorts() const
        { return 0; }
        // Get the number of output ports this element has.
        virtual unsigned GetNumOutputPorts() const
        { return 0; }
        // Get an input port at the given index. The index must be valid.
        virtual Port& GetInputPort(unsigned index)
        { BUG("No such input port index."); }
        // Get an ouput port at the given index. The index must be valid.
        virtual Port& GetOutputPort(unsigned index)
        { BUG("No such output port index."); }
        // Receive and handle an element specific command.
        virtual void ReceiveCommand(Command& cmd)
        { BUG("Unexpected command."); }
        virtual bool DispatchCommand(const std::string& dest, Command& cmd)
        { return false; }

        // Find an input port by name. Returns nullptr if no such port.
        Port* FindInputPortByName(const std::string& name)
        { return FindInputPort([name](auto& port) { return port.GetName() == name; }); }
        // Find an input port by name. Returns nullptr if no such port.
        Port* FindOutputPortByName(const std::string& name)
        { return FindOutputPort([name](auto& port) { return port.GetName() == name; }); }

        bool HasInputPort(Port* port)
        { return FindInputPort([port](auto& other) { return &other == port; }); }
        bool HasOutputPort(Port* port)
        { return FindOutputPort([port](auto& other) { return &other == port; }); }

        template<typename CmdT> static
        std::unique_ptr<Command> MakeCommand(CmdT&& cmd)
        {
            using CmdType = detail::MessageImpl<std::remove_reference_t<CmdT>, 0>;
            auto ret = std::make_unique<CmdType>(std::forward<CmdT>(cmd));
            return ret;
        }

    private:
        template<typename Predicate>
        Port* FindInputPort(const Predicate& predicate)
        {
            for (unsigned i=0; i<GetNumInputPorts(); ++i)
            {
                auto& port = GetInputPort(i);
                if (predicate(port))
                    return &port;
            }
            return nullptr;
        }
        template<typename Predicate>
        Port* FindOutputPort(const Predicate& predicate)
        {
            for (unsigned i=0; i<GetNumOutputPorts(); ++i)
            {
                auto& port = GetOutputPort(i);
                if (predicate(port))
                    return &port;
            }
            return nullptr;
        }
    private:
    };


} // namespace