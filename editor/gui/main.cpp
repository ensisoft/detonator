// Copyright (C) 2020-2021 Sami Väisänen
// Copyright (C) 2020-2021 Ensisoft http://www.ensisoft.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#define LOGTAG "main"

#include "config.h"

#include "warnpush.h"
#  include <QCoreApplication>
#  include <QApplication>
#  include <QSurfaceFormat>
#  include <QStringList>
#  include <QFileInfo>
#  include <QDir>
#  include <QFile>
#  include <QTextStream>
#  include <QEventLoop>
#  include <QObject>
#  include <boost/version.hpp>
#  include <box2d/box2d.h>
#  include <nlohmann/json.hpp>
#  include <hb.h> // harfbuzz
#  include <sol/sol.hpp>
#  include <assimp/version.h>
   #if defined(WINDOWS_OS)
   #  include <Windows.h>
   #  include <dwmapi.h>
   #  include <timeapi.h>
   #  pragma comment(lib, "Dwmapi.lib")
   #  pragma comment(lib, "Winmm.lib")
   #endif
#include "warnpop.h"

#include <iostream>
#include <vector>
#include <thread>
#include <chrono>

// A file generated by the CMake cmake_git_version_tracking module
#include "git.h"

#include "base/logging.h"
#include "base/cmdline.h"
#include "base/threadpool.h"
#include "editor/app/eventlog.h"
#include "editor/app/utility.h"
#include "editor/gui/types.h"
#include "editor/gui/main.h"
#include "editor/gui/mainwindow.h"
#include "editor/gui/viewwindow.h"
#include "editor/gui/framelesswindow/framelesswindow.h"

namespace gui {

bool Editor::notify(QObject* receiver, QEvent* e)
{
    try
    {
        return QApplication::notify(receiver, e);
    }
    catch (const std::exception& e)
    {
        ERROR("Uncaught exception: '%1'", e.what());
    }
    return false;
}

// static
bool Editor::mDebugEditor = false;
// static
bool Editor::mDevEditor = false;

// static
bool Editor::DebugEditor()
{
    return mDebugEditor;
}
// static
bool Editor::DevEditor()
{
    return mDevEditor;
}

// static
void Editor::SetEditorDebug(bool on_off)
{
    mDebugEditor = on_off;
}
// static
void Editor::SetEditorDev(bool on_off)
{
    mDevEditor = on_off;
}

} // namespace

void copyright()
{
    const auto boost_major    = BOOST_VERSION / 100000;
    const auto boost_minor    = BOOST_VERSION / 100 % 1000;
    const auto boost_revision = BOOST_VERSION % 100;

    INFO("https://github.com/Jorgen-VikingGod/Qt-Frameless-Window-DarkStyle");
    INFO("Frameless window");
    INFO("Copyright (c) 2018 Juergen Skrotzky");
    INFO("https://github.com/Jorgen-VikingGod");
    INFO("JorgenVikingGod@gmail.com");

    INFO("https://github.com/antonypro/QGoodWindow");
    INFO("Qt DarkStyle");
    INFO("Copyright (c) 2018-2024 Antonio Dias");

    INFO("https://github.com/assimp");
    INFO("https://assimp.org/");
    INFO("Assimp the Asset Importer Library %1.%2.%3", aiGetVersionMajor(), aiGetVersionMinor(), aiGetVersionRevision());
    INFO("Copyright (c) 2006-2023, assimp team");

    INFO("http://http://mpg123.de/");
    INFO("mpg123 - Fast console MPEG Audio Player and decoder library. 1.26.4");

    INFO("http://www.boost.org");
    INFO("Boost software library %1.%2.%3", boost_major, boost_minor, boost_revision);

    INFO("http://www.small-icons.com/stock-icons/16x16-free-application-icons.htm");
    INFO("http://www.aha-soft.com");
    INFO("Copyright (c) 2009 Aha-Soft");
    INFO("16x16 Free Application Icons");

    INFO("http://www.famfamfam.com/lab/icons/silk/");
    INFO("Silk Icon Set 1.3 Copyright (c) Mark James");

    INFO("http://qt.nokia.com");
    INFO("Qt cross-platform application and UI framework %1", QT_VERSION_STR);

    INFO("Copyright (C) 2013-2017 Mattia Basaglia <mattia.basaglia@gmail.com>");
    INFO("https://github.com/mbasaglia/Qt-Color-Widgets");
    INFO("Qt Color Widgets");

    INFO("Copyright (c) 2018-2021 Max Brunsfeld");
    INFO("https://github.com/tree-sitter/tree-sitter");
    INFO("Tree-sitter parser generator and incremental parsing library.");

    INFO("Copyright (c) 2005 - 2012 G-Truc Creation (www.g-truc.net)");
    INFO("https://github.com/g-truc/glm");
    INFO("OpenGL Mathematics (GLM) 0.9.9.8");

    INFO("Copyright (c) 2019 Erin Catto");
    INFO("https://box2d.org/");
    INFO("Box2D a 2D Physics Engine for Games %1.%2.%3", b2_version.major, b2_version.minor, b2_version.revision);

    INFO("Copyright (C) 2005-2017 Erik de Castro Lopo <erikd@mega-nerd.com>");
    INFO("http://libsndfile.github.io/libsndfile/");
    INFO("libsndfile C library for sampled audio data. 1.0.30");

    INFO("Copyright (c) 2012-2016, Erik de Castro Lopo <erikd@mega-nerd.com>");
    INFO("http://http://libsndfile.github.io/libsamplerate/");
    INFO("libsamplerate C library for audio resampling/sample rate conversion. 0.2.1");

    INFO("Copyright (c) 2013-2019 Niels Lohmann <http://nlohmann.me>");
    INFO("https://github.com/nlohmann/json");
    INFO("JSON for Modern C++ %1.%2.%3", NLOHMANN_JSON_VERSION_MAJOR,
         NLOHMANN_JSON_VERSION_MINOR, NLOHMANN_JSON_VERSION_MINOR);

    INFO("Copyright (c) 2019 Daniil Goncharov <neargye@gmail.com>");
    INFO("https://github.com/Neargye/magic_enum");
    INFO("Magic Enum C++ 0.6.4");

    INFO("Copyright (c) 2017 Sean Barrett");
    INFO("http://nothings.org/stb");
    INFO("Public domain image loader v2.23");

    INFO("Copyright (c) 2017 Sean Barrett");
    INFO("http://nothings.org/stb");
    INFO("Public domain image writer v1.13");

    INFO("Copyright © 2011  Google, Inc.");
    INFO("Harfbuzz text shaping library %1", HB_VERSION_STRING);

    INFO("Copyright (C) 1996-2020 by David Turner, Robert Wilhelm, and Werner Lemberg.");
    INFO("Freetype text rendering library 2.10.4");

    INFO("Copyright (C) 1994-2020 Lua.org, PUC-Rio.");
    INFO("Lua.org, PUC-Rio, Brazil (http://www.lua.org)");
    INFO("https://github.com/lua/lua");
    INFO("Lua %1.%2.%3", LUA_VERSION_MAJOR, LUA_VERSION_MINOR, LUA_VERSION_RELEASE);

    INFO("Copyright (c) 2013-2020 Rapptz, ThePhD, and contributors");
    INFO("https://github.com/ThePhD/sol2");
    INFO("https://sol2.rtfd.io");
    INFO("sol2 C++ Lua library binding. %1", SOL_VERSION_STRING);

    INFO("Copyright (C) 2005-2020 Sergey A. Tachenov and contributors");
    INFO("Distributed under LGPL, full details in the COPYING file.");
    INFO("Original ZIP package is copyrighted by Gilles Vollant, see");
    INFO("quazip/(un)zip.h files for details, but basically it's the zlib license.");
    INFO("https://github.com/stachenov/quazip");
    INFO("https://stachenov.github.io/quazip/");

    INFO("Free icons from Icons8");
    INFO("https://icons8.com");

    INFO("http://www.ensisoft.com");
    INFO("https://github.com/ensisoft/detonator");
    INFO("Compiler: %1 %2", COMPILER_NAME , COMPILER_VERSION);
    INFO("Compiled: " __DATE__ ", " __TIME__);
    INFO("Copyright (c) Sami Väisänen 2020-2023");
    INFO("Built on branch '%1' with commit %2", git_Branch(), git_CommitSHA1());
    INFO(APP_TITLE ", " APP_VERSION);
}

bool PlatformSync()
{
#if defined(WINDOWS_OS)
    // https://stackoverflow.com/questions/45676892/reliable-windowed-vsync-with-opengl-on-windows
    // https://bugs.chromium.org/p/chromium/issues/detail?id=467617

    // Try to synchronize with the VBLANK. DmwFlush requires the Windows compositor (Aero)
    // to be running. Alternative would be the D3DKMTWaitForVerticalBlankEvent but that requires
    // more elaborate setup.
    DwmFlush();

    return true;
#endif
    return false;
}

template<typename Window>
void EventLoop(QApplication& app, Window& window)
{
#if defined(WINDOWS_OS)
    // try to adjust the timer resolution to something better.
    // https://learn.microsoft.com/en-us/windows/win32/api/timeapi/nf-timeapi-timebeginperiod
    timeBeginPeriod(1);

    // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setpriorityclass
    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
#endif

    // use a dedicated thread to give the main application thread
    // a steady heartbeat to trigger one iteration of the "game loop".
    std::thread heartbeat([&window]() {
        while (!window.IsClosed()) {
            // not really thread safe but ok, just a read
            const auto frame_delay = window.GetFrameDelay();
            // postEvent is thread safe
            if (!gui::GameLoopEvent::IsPending())
                QCoreApplication::postEvent(&window, new gui::GameLoopEvent);

            // throttle the CPU and frame rate
            if (window.TryVSync())
            {
                if (PlatformSync())
                    continue;
            }
            if (frame_delay)
                std::this_thread::sleep_for(std::chrono::milliseconds(frame_delay));
        }
    });

    // run the mainloop
    // this isn't the conventional way to run a qt based
    // application's main loop. normally one would just call
    // app.exec() but it seems to greatly degrade the performance
    // up to an order of magnitude difference in rendering perf
    // as measured by frames per second.
    // the problem with this type of loop however is that on a modern
    // machine with performant GPU were the GPU workloads are small
    // and without sync to VBLANK enabled we're basically going
    // to be running a busy loop here burning a lot of cycles for nothing.
    while (!window.IsClosed())
    {
        // why are we not calling iterateMainLoop directly here??
        // the problem has to do with modal dialogs. When a modal
        // dialog is open Qt enters a temporary event loop which
        // would mean that this code would not get a chance to render.
        // thus, the iteration of the main loop code in the mainwindow
        // is triggered by an event posted to the application queue
        app.processEvents(QEventLoop::ProcessEventsFlag::AllEvents |
                          QEventLoop::ProcessEventsFlag::WaitForMoreEvents);
    }
    heartbeat.join();

    DEBUG("Exiting...");
}


void ViewerMain(const std::string& style, const std::string& ipc_socket, QApplication& app)
{
    // This logger forwards lower level log events
    // from the subsystems that to the stdout (ostream)
    // with the idea that the editor's "main" instance
    // will read the stdout and extract the log data
    // coming from *this* process and display it in the
    // editor process's event log.
    class ForwardingLogger : public base::Logger
    {
    public:
        ForwardingLogger() : mLogger(std::cout)
        {
            mLogger.EnableTerminalColors(false);
        }
        virtual void Write(base::LogEvent type, const char* file, int line, const char* msg, double time) override
        {
            // 1. strip the file/line information. Events written into
            // gamehosts's app::EventLog don't have this.
            // 2. encode the type of the message in the message itself
            // and write to stdout for the editor process to read it.
            std::string prefix;
            if (type == base::LogEvent::Error)
                prefix = "E: ";
            else if (type == base::LogEvent::Warning)
                prefix = "W: ";
            else if (type == base::LogEvent::Info)
                prefix = "I: ";
            else if (type == base::LogEvent::Debug)
                prefix = "D: ";

            std::string message;
            message.append(prefix);
            message.append(msg);
            message.append("\n");
            // write to the stdout (via OStreamLogger and std::cout)
            // so that the main editor process can capture the output
            // and write it to the event log.
            mLogger.Write(type, message.c_str());
        }

        virtual void Write(base::LogEvent type, const char* msg) override
        {
            mLogger.Write(type, msg);
        }
        virtual void Flush() override
        {
            mLogger.Flush();
        }
        virtual base::bitflag<base::Logger::WriteType> GetWriteMask() const override
        {
            base::bitflag<base::Logger::WriteType> ret;
            ret.set(base::Logger::WriteType::WriteRaw, !mWriteFormatted);
            ret.set(base::Logger::WriteType::WriteFormatted, mWriteFormatted);
            return ret;
        }
    private:
        base::OStreamLogger mLogger;
        bool mWriteFormatted = false;
    };

    // set the logger object for the subsystem to use, we'll
    // direct all this to the terminal for now.
    base::LockedLogger<ForwardingLogger> logger((ForwardingLogger()));
    base::SetGlobalLog(&logger);
    base::EnableDebugLog(true);
    DEBUG("It's alive!");
    DEBUG(app.applicationDirPath());

    // capture log events written into app::EventLog and forward
    // them to the base logger which writes them to stdout
    // which is re-directed to a file when this process is started
    // by the GSEditor process.
    app::EventLog::get().OnNewEvent = [](const app::Event& event) {

        //base::Write
        base::LogEvent type;
        if (event.type == app::Event::Type::Info)
            type = base::LogEvent::Info;
        else if (event.type == app::Event::Type::Warning)
            type = base::LogEvent::Warning;
        else if (event.type == app::Event::Type::Error)
            type = base::LogEvent::Error;
        else if (event.type == app::Event::Type::Debug)
            type = base::LogEvent::Debug;
        else return;
        auto msg = app::ToUtf8(event.message);
        // currently, the app::Event information doesn't have file/line
        // information.
        auto* logger = base::GetGlobalLog();
        if (logger->TestWriteMask(base::Logger::WriteType::WriteRaw)) {
            logger->Write(type, __FILE__, __LINE__, msg.c_str(), 0.0); // todo: time value (the forwarding
                                                                       // logger doesn't use it now either
        }
        if (logger->TestWriteMask(base::Logger::WriteType::WriteFormatted)) {
            msg.append("\n");
            logger->Write(type, msg.c_str());
        }
    };

    if (!style.empty())
    {
        app::SetStyle(app::FromUtf8(style));
    }

    gui::ViewWindow window(app);
    window.show();
    window.Connect(app::FromUtf8(ipc_socket));

    if (!style.empty())
    {
        app::SetTheme(app::FromUtf8(style));
    }

    EventLoop(app, window);
}

void EditorMain(QApplication& app)
{
    // prefix with a . to make this a "hidden" dir
    // which is the convention on Linux
    app::InitializeAppHome(".Gamestudio Editor");

    // This logger forwards lower level log events
    // from the subsystems that use base/logging to
    // the application's event log and to the console.
    class ForwardingLogger : public base::Logger
    {
    public:
        ForwardingLogger() : mLogger(std::cout)
        {
            mLogger.SetStyle(base::OStreamLogger::Style::FancyColor);
        }

        virtual void Write(base::LogEvent type, const char* file, int line, const char* msg, double time) override
        {
            auto& event_log = app::EventLog::get();
            // forward Error and warnings to the application log too.
            if (type == base::LogEvent::Error)
                event_log.write(app::Event::Type::Error, app::toString(msg), "engine");
            else if (type == base::LogEvent::Warning)
                event_log.write(app::Event::Type::Warning, app::toString(msg), "engine");
            else if (type == base::LogEvent::Info)
                event_log.write(app::Event::Type::Info, app::toString(msg), "engine");

            // write to the console/terminal as well.
            mLogger.Write(type, file, line, msg, time);
        }

        virtual void Write(base::LogEvent type, const char* msg) override
        {}
        virtual void Flush() override
        {
            mLogger.Flush();
        }
        virtual base::bitflag<WriteType> GetWriteMask() const override
        { return WriteType::WriteRaw; }
    private:
        base::OStreamLogger mLogger;
    };

    // set the logger object for the subsystem to use, we'll
    // direct all this to the terminal for now.
    base::LockedLogger<ForwardingLogger> logger((ForwardingLogger()));
    base::SetGlobalLog(&logger);
    base::EnableDebugLog(true);
    DEBUG("It's alive!");

    copyright();

    base::ThreadPool threadpool;
    threadpool.AddRealThread(base::ThreadPool::Worker0ThreadID);
    threadpool.AddRealThread(base::ThreadPool::Worker1ThreadID);
    threadpool.AddRealThread(base::ThreadPool::Worker2ThreadID);
    threadpool.AddRealThread(base::ThreadPool::Worker3ThreadID);
    threadpool.AddMainThread();
    base::SetGlobalThreadPool(&threadpool);

    FramelessWindow framelessWindow;
    framelessWindow.enableShadow(false);
    framelessWindow.init();

    // Create the application main window into which we add
    // main widgets.
    gui::MainWindow window(app, &threadpool);

    window.LoadSettings();
    window.LoadLastState(&framelessWindow);
    window.showWindow();

    framelessWindow.setContent(&window);
    framelessWindow.show();

    bool load_last_workspace = true;
    // check if we have a flag to disable workspace loading.
    // useful for development purposes when you know the workspace
    // might not load properly.
    const QStringList& args = app.arguments();
    for (const QString& arg : args)
    {
        if (arg == "--no-workspace")
            load_last_workspace = false;
    }
    if (load_last_workspace)
    {
        window.LoadLastWorkspace();
    }

    EventLoop(app, window);

    ASSERT(threadpool.HasPendingTasks() == false);
    threadpool.Shutdown();
    base::SetGlobalThreadPool(nullptr);
}

int Main(int argc, char* argv[])
{
    base::CommandLineOptions options;
    options.Add("--viewer", "Launch project viewer only.");
    options.Add("--app-style", "Name of the style to apply.", std::string(""));
    options.Add("--socket-name", "Name of the local socket to connect to.", std::string(""));
    options.Add("--no-workspace", "Don't load any previous workspace");
    options.Add("--no-session", "Don't load any previous window session within a workspace.");
    options.Add("--help", "Print this help.");
    options.Add("--verbose", "Enable verbose debug logs.");
    options.Add("--editor-debug", "Enable editor debug features.");
    options.Add("--editor-dev", "Enable editor developer features.");

    bool viewer_mode = false;
    std::string arg_parse_error;
    std::string ipc_socket_name;
    std::string style;
    if (!options.Parse(base::CreateStandardArgs(argc, argv), &arg_parse_error))
    {
        std::cout << arg_parse_error;
        std::cout << std::endl;
        return 0;
    }
    else if (options.WasGiven("--help"))
    {
        options.Print(std::cout);
        return 0;
    }
    viewer_mode = options.WasGiven("--viewer");
    if (viewer_mode)
    {
        if (!options.GetValue("--socket-name", &ipc_socket_name))
            ipc_socket_name = "gamestudio-local-socket";
        options.GetValue("--app-style", &style);
    }

    if (options.WasGiven("--verbose"))
    {
        base::EnableLogEvent(base::LogEvent::Verbose, true);
    }

    if (options.WasGiven("--editor-debug"))
    {
        gui::Editor::SetEditorDebug(true);
        DEBUG("Editor debug features are enabled.");
    }

    if (options.WasGiven("--editor-dev"))
    {
        gui::Editor::SetEditorDev(true);
        DEBUG("Editor developer features are enabled.");
    }

    // turn on Qt logging: QT_LOGGING_RULES = qt.qpa.gl
    // turns out this attribute is needed in order to make Qt
    // create a GLES2 context.
    // https://lists.qt-project.org/pipermail/interest/2015-February/015404.html
    QCoreApplication::setAttribute(Qt::AA_UseOpenGLES);
    //QCoreApplication::setAttribute(Qt::AA_NativeWindows);

    // set the aliases for icon search paths
    QDir::setSearchPaths("icons", QStringList(":/16x16_ico_png"));
    QDir::setSearchPaths("level", QStringList(":/32x32_ico_png"));
    QDir::setSearchPaths("icons16", QStringList(":/16x16_ico_png"));
    QDir::setSearchPaths("icons32", QStringList(":/32x32_ico_png"));
    QDir::setSearchPaths("icons64", QStringList(":/64x64_ico_png"));

    // Set default surface format.
    // note that the alpha channel is not used on purpose.
    // using an alpha channel will cause artifacts with alpha
    // compositing window compositor such as picom. i.e. the
    // background surfaces in the compositor's window stack will
    // show through. in terms of alpha blending the game content
    // whether the destination color buffer has alpha channel or
    // not should be irrelevant.
    QSurfaceFormat format;
    format.setVersion(3, 0);
    format.setProfile(QSurfaceFormat::CoreProfile);
    format.setRenderableType(QSurfaceFormat::OpenGLES);
    format.setDepthBufferSize(24);
    format.setAlphaBufferSize(0); // no alpha channel
    format.setRedBufferSize(8);
    format.setGreenBufferSize(8);
    format.setBlueBufferSize(8);
    format.setStencilBufferSize(8);
    format.setSamples(4);
    format.setSwapInterval(0);
    format.setSwapBehavior(QSurfaceFormat::DoubleBuffer);
    format.setColorSpace(QSurfaceFormat::ColorSpace::sRGBColorSpace);
    QSurfaceFormat::setDefaultFormat(format);

    QApplication app(argc, argv);

    // Add a path for Qt to look for the plugins at runtime
    // note that this needs to be called *after* the QApplication object has been created.
    QCoreApplication::addLibraryPath(app::JoinPath(QCoreApplication::applicationDirPath(), "plugins"));

    if (viewer_mode)
    {
        ViewerMain(style, ipc_socket_name, app);
        return 0;
    }

    EditorMain(app);
    return 0;
}

int main(int argc, char* argv[])
{
    int ret = 0;
    try
    {
        ret = Main(argc, argv);
    }
    catch (const std::exception& e)
    {
        std::cerr << "Oops... something went wrong.";
        std::cerr << e.what();
        std::cerr << std::endl;
    }
    std::cout << "Have a good day.\n";
    std::cout << std::endl;
    return ret;
}
